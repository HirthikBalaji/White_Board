<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Physics Whiteboard ‚Äî v3</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',sans-serif;margin:0}
    .tool-btn{padding:.5rem;border-radius:.5rem;cursor:pointer}
    .tool-btn.active,.tool-btn:hover{background:#3b82f6;color:#fff}
    .color-box{width:1.6rem;height:1.6rem;border-radius:.375rem;cursor:pointer;border:2px solid transparent}
    .color-box.active{border-color:#3b82f6}
    #mainCanvas{cursor:crosshair;background:white;border-radius:.5rem;box-shadow:0 6px 18px rgba(0,0,0,.08)}
    #ruler,#protractor{position:absolute;cursor:grab;user-select:none;display:none;z-index:30}
    #ruler:active,#protractor:active{cursor:grabbing}
    #text-input{position:absolute;z-index:40;display:none;border:1px solid #3b82f6;background:rgba(255,255,255,0.95);padding:.25rem;border-radius:.25rem}
    .sidebar{width:88px}
  </style>
</head>
<body class="flex h-screen bg-gray-100">
  <div class="sidebar bg-white p-3 flex flex-col items-center space-y-2 shadow-lg">
    <div class="font-bold text-blue-600">Tools</div>
    <button id="tool-pointer" class="tool-btn" title="Pointer">‚òùÔ∏è</button>
    <button id="tool-pen" class="tool-btn active" title="Pen">‚úèÔ∏è</button>
    <button id="tool-highlighter" class="tool-btn" title="Highlighter">üñçÔ∏è</button>
    <button id="tool-eraser" class="tool-btn" title="Eraser">üßΩ</button>
    <button id="tool-line" class="tool-btn" title="Line">üìè</button>
    <button id="tool-rect" class="tool-btn" title="Rectangle">‚ñ≠</button>
    <button id="tool-circle" class="tool-btn" title="Circle">‚ö™</button>
    <button id="tool-text" class="tool-btn" title="Text">üÖ∞Ô∏è</button>
    <div class="w-full border-t my-1"></div>
    <input id="colorPicker" type="color" value="#000000" class="mt-1">
    <input id="sizePicker" type="range" min="1" max="40" value="4" class="w-full mt-2">
    <div class="w-full flex flex-col items-center space-y-1 mt-2">
      <button id="undoBtn" class="tool-btn w-full">‚Ü©Ô∏è Undo</button>
      <button id="redoBtn" class="tool-btn w-full">‚Ü™Ô∏è Redo</button>
      <button id="clearBtn" class="tool-btn w-full">üóë Clear</button>
    </div>
    <div class="w-full border-t my-1"></div>
    <input id="pdf-upload" type="file" accept="application/pdf" class="text-xs"/>
    <button id="export-png" class="tool-btn w-full">‚¨áÔ∏è PNG</button>
    <button id="export-pdf" class="tool-btn w-full">‚¨áÔ∏è PDF</button>
    <button id="toggle-ruler" class="tool-btn w-full">üìê Ruler</button>
    <button id="toggle-protractor" class="tool-btn w-full">üåì Protractor</button>
  </div>

  <div id="canvas-container" class="flex-1 p-4 relative">
    <canvas id="mainCanvas"></canvas>
    <img id="ruler" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MDAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MDAgNTAiPgo8ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSI+CjxwYXRoIGQ9Ik0wIDI1IEw1MDAgMjUiLz4KPHBhdGggZD0iTTAgMCBMNTAwIDAgTDUwMCA1MCBMMCA1MCBMMCAwIiBzdHJva2Utd2lkdGg9IjIiLz4KPHJlY3Qgd2lkdGg9IjUwMCIgaGVpZ2h0PSI1MCIgZmlsbD0icmdiYSgyNDgsIDIxMSwgMTQ1LCAwLjcpIi8+CjwvZz4KPGcgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIHN0cm9rZT0ibm9uZSIgZmlsbD0iIzAwMCI+CjxsaW5lIHgxPSI1MCIgeTE9IjI1IiB4Mj0iNTAiIHkyPSIxNSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEiLz4KPHRleHQgeD0iNTAiIHk9IjEwIj4xPC90ZXh0Pgo8bGluZSB4MT0iMTAwIiB5MT0iMjUiIHgyPSIxMDAiIHkyPSIxNSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEiLz4KPHRleHQgeD0iMTAwIiB5PSIxMCI+MjwvdGV4dD4KPGxpbmUgeDE9IjE1MCIgeTE9IjI1IiB4Mj0iMTUwIiB5Mj0iMTUiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjx0ZXh0IHg9IjE1MCIgeT0iMTAiPjM8L3RleHQ+CjxsaW5lIHgxPSIyMDAiIHkxPSIyNSIgeDI9IjIwMCIgeTI9IjE1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8dGV4dCB4PSIyMDAiIHk9IjEwIj40PC90ZXh0Pgo8bGluZSB4MT0iMjUwIiB5MT0iMjUiIHgyPSIyNTAiIHkyPSIxNSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEiLz4KPHRleHQgeD0iMjUwIiB5PSIxMCI+NTwvdGV4dD4KPHxsaW5lIHgxPSIzMDAiIHkxPSIyNSIgeDI9IjMwMCIgeTI9IjE1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8dGV4dCB4PSIzMDAiIHk9IjEwIj42PC90ZXh0Pgo8bGluZSB4MT0iMzUwIiB5MT0iMjUiIHgyPSIzNTAiIHkyPSIxNSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEiLz4KPHRleHQgeD0iMzUwIiB5PSIxMCI+NzwvdGV4dD4KPGxpbmUgeDE9IjQwMCIgeTE9IjI1IiB4Mj0iNDAwIiB5Mj0iMTUiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjx0ZXh0IHg9IjQwMCIgeT0iMTAiPjg8L3RleHQ+CjxsaW5lIHgxPSI0NTAiIHkxPSIyNSIgeDI9IjQ1MCIgeTI9IjE1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8dGV4dCB4PSI0NTAiIHk9IjEwIj45PC90ZXh0Pgo8L2c+Cjwvc3ZnPg==" width="420" alt="Ruler">
    <img id="protractor" src="https://github.com/HirthikBalaji/White_Board/blob/main/3y_dlim2srle9kmspqvcdkn4orcclpiqc9i.jpg?raw=true" width="220" alt="Ruler">
    <textarea id="text-input" placeholder="Enter text"></textarea>
  </div>

<script>
// ====== Setup & State ======
const canvas = document.getElementById('mainCanvas');
const container = document.getElementById('canvas-container');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('colorPicker');
const sizePicker = document.getElementById('sizePicker');
const textInput = document.getElementById('text-input');
let dpr = window.devicePixelRatio || 1;
let viewW = 800, viewH = 600;

let currentTool = 'pen';
let currentColor = colorPicker.value;
let currentSize = parseInt(sizePicker.value, 10);

let objects = []; // list of drawable objects (vector-like)
let current = null; // current object being drawn or transformed
let isPointerDown = false;
let pointerDownPos = {x:0,y:0};
let selected = null; // selected object for pointer tool

let backgroundImageDataUrl = null; // for imported PDF page (single page)

// History (undo/redo)
let history = [];
let historyIndex = -1;
function pushHistory() {
  // store deep clone of objects and background image
  const snapshot = {
    objects: JSON.parse(JSON.stringify(objects)),
    bg: backgroundImageDataUrl
  };
  // discard anything after current index
  history = history.slice(0, historyIndex+1);
  history.push(snapshot);
  historyIndex = history.length - 1;
  // limit history
  if(history.length > 60) { history.shift(); historyIndex--; }
}
function undo() {
  if(historyIndex <= 0) return;
  historyIndex--;
  const snap = history[historyIndex];
  objects = JSON.parse(JSON.stringify(snap.objects));
  backgroundImageDataUrl = snap.bg;
  selected = null; current = null;
  renderAll();
}
function redo() {
  if(historyIndex >= history.length - 1) return;
  historyIndex++;
  const snap = history[historyIndex];
  objects = JSON.parse(JSON.stringify(snap.objects));
  backgroundImageDataUrl = snap.bg;
  selected = null; current = null;
  renderAll();
}

// ====== Canvas sizing (handles DPR) ======
function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  viewW = Math.max(200, rect.width - 40);
  viewH = Math.max(200, rect.height - 40);
  canvas.style.width = viewW + 'px';
  canvas.style.height = viewH + 'px';
  canvas.width = Math.round(viewW * dpr);
  canvas.height = Math.round(viewH * dpr);
  // scale so drawing units are CSS pixels
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  renderAll();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ====== Utility helpers ======
function uid(prefix='o'){return prefix + Date.now().toString(36) + Math.floor(Math.random()*1000)}
function dist(ax,ay,bx,by){return Math.hypot(ax-bx, ay-by)}

function pointToSegmentDistance(px,py, x1,y1,x2,y2){
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A * C + B * D;
  const len_sq = C*C + D*D;
  let param = -1;
  if (len_sq !== 0) param = dot / len_sq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  return dist(px,py,xx,yy);
}

function getObjectBBox(obj){
  if(obj.type==='path'){
    const xs = obj.points.map(p=>p.x); const ys = obj.points.map(p=>p.y);
    return {x:Math.min(...xs), y:Math.min(...ys), w:Math.max(...xs)-Math.min(...xs), h:Math.max(...ys)-Math.min(...ys)};
  }
  if(obj.type==='shape'){
    const x1 = obj.x1, y1 = obj.y1, x2 = obj.x2, y2 = obj.y2;
    const x = Math.min(x1,x2), y = Math.min(y1,y2), w = Math.abs(x2-x1), h = Math.abs(y2-y1);
    return {x,y,w,h};
  }
  if(obj.type==='text'){
    // approx using font size
    const w = (obj.text.length || 1) * (obj.size * 0.6);
    const h = obj.size;
    return {x: obj.x, y: obj.y, w, h};
  }
  return {x:0,y:0,w:0,h:0};
}

function hitTest(obj, x, y){
  if(obj.type === 'path'){
    const threshold = (obj.size || 4) + 6;
    const pts = obj.points;
    if(pts.length === 1) return dist(pts[0].x, pts[0].y, x, y) <= threshold;
    for(let i=0;i<pts.length-1;i++){
      if(pointToSegmentDistance(x,y, pts[i].x, pts[i].y, pts[i+1].x, pts[i+1].y) <= threshold) return true;
    }
    return false;
  }
  if(obj.type === 'shape'){
    if(obj.shape === 'line'){
      return pointToSegmentDistance(x,y, obj.x1, obj.y1, obj.x2, obj.y2) <= (obj.size + 6);
    }
    const bb = getObjectBBox(obj);
    // for rect and circle allow near-border detection
    if(obj.shape === 'rect') return x >= bb.x && x <= bb.x+bb.w && y >= bb.y && y <= bb.y+bb.h;
    if(obj.shape === 'circle'){
      const cx = obj.x1, cy = obj.y1, r = obj.r;
      return dist(cx,cy,x,y) <= r + (obj.size+6);
    }
  }
  if(obj.type === 'text'){
    const bb = getObjectBBox(obj);
    return x >= bb.x && x <= bb.x+bb.w && y >= bb.y && y <= bb.y+bb.h;
  }
  return false;
}

// ====== Rendering ======
function renderAll(){
  // clear
  ctx.clearRect(0,0, viewW, viewH);
  // white background
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0, viewW, viewH);
  // background image if any
  if(backgroundImageDataUrl){
    const img = new Image();
    img.onload = ()=>{
      ctx.drawImage(img, 0, 0, viewW, viewH);
      // after drawing background draw objects
      drawObjects();
    };
    img.src = backgroundImageDataUrl;
  } else {
    drawObjects();
  }
}

function drawObjects(){
  for(let i=0;i<objects.length;i++) drawObject(objects[i], false);
  if(current){ drawObject(current, true); }
  // draw selection if present
  if(selected){
    const bb = getObjectBBox(selected);
    ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle='#3b82f6'; ctx.lineWidth=1;
    ctx.strokeRect(bb.x-6, bb.y-6, bb.w+12, bb.h+12);
    ctx.restore();
  }
}

function drawObject(obj, isTemp=false){
  if(obj.type === 'path'){
    ctx.save();
    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = obj.size; ctx.strokeStyle = obj.color;
    ctx.globalAlpha = obj.tool === 'highlighter' ? 0.3 : 1;
    ctx.beginPath();
    const pts = obj.points;
    if(pts.length){ ctx.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.stroke(); }
    ctx.restore();
  } else if(obj.type === 'shape'){
    ctx.save(); ctx.lineWidth = obj.size; ctx.strokeStyle = obj.color; ctx.fillStyle = 'transparent'; ctx.beginPath();
    if(obj.shape === 'line'){ ctx.moveTo(obj.x1,obj.y1); ctx.lineTo(obj.x2,obj.y2); ctx.stroke(); }
    if(obj.shape === 'rect'){ ctx.strokeRect(Math.min(obj.x1,obj.x2), Math.min(obj.y1,obj.y2), Math.abs(obj.x2-obj.x1), Math.abs(obj.y2-obj.y1)); }
    if(obj.shape === 'circle'){ const r = obj.r || Math.hypot(obj.x2-obj.x1, obj.y2-obj.y1); ctx.arc(obj.x1,obj.y1,r,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  } else if(obj.type === 'text'){
    ctx.save(); ctx.fillStyle = obj.color; ctx.font = `${obj.size}px sans-serif`; ctx.textBaseline = 'top'; ctx.fillText(obj.text, obj.x, obj.y); ctx.restore();
  }
}

// ====== Pointer position helper ======
function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
}

// ====== Pointer events (handles drawing, erasing, pointer move) ======
canvas.addEventListener('pointerdown', (e)=>{
  const pos = getPointerPos(e);
  isPointerDown = true;
  pointerDownPos = pos;
  if(currentTool === 'pointer'){
    // hit test top-down
    selected = null;
    for(let i = objects.length-1; i>=0; i--){ if(hitTest(objects[i], pos.x, pos.y)){ selected = objects[i]; selected._dragOffset = {x: pos.x, y: pos.y}; break; } }
    renderAll();
    return;
  }

  if(currentTool === 'eraser'){
    // immediate erase objects that touch this point (continuous while move)
    eraseAt(pos.x,pos.y);
    current = { type: 'eraserCursor', x: pos.x, y: pos.y, size: currentSize };
    renderAll();
    return;
  }

  // start drawing a new object depending on tool
  if(currentTool === 'pen' || currentTool === 'highlighter'){
    current = { id: uid('p'), type: 'path', tool: currentTool, color: currentColor, size: currentSize, points: [{x: pos.x, y: pos.y}] };
  } else if(['line','rect','circle'].includes(currentTool)){
    current = { id: uid('s'), type: 'shape', shape: currentTool, color: currentColor, size: currentSize, x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y, r: 0 };
  } else if(currentTool === 'text'){
    textInput.style.left = (pos.x + canvas.getBoundingClientRect().left) + 'px';
    textInput.style.top = (pos.y + canvas.getBoundingClientRect().top) + 'px';
    textInput.style.display = 'block'; textInput.value=''; textInput.focus();
    // temporarily store where text will go
    current = { id: uid('t'), type: 'text', x: pos.x, y: pos.y, text: '', color: currentColor, size: currentSize * 4 };
  }
  renderAll();
});

canvas.addEventListener('pointermove', (e)=>{
  const pos = getPointerPos(e);
  if(!isPointerDown){
    // show eraser cursor when hovering
    if(currentTool === 'eraser'){ current = { type:'eraserCursor', x: pos.x, y: pos.y, size: currentSize }; renderAll(); }
    return;
  }

  if(currentTool === 'pointer'){
    if(selected){
      const dx = pos.x - selected._dragOffset.x; const dy = pos.y - selected._dragOffset.y;
      // translate object
      if(selected.type === 'path'){
        for(let p of selected.points){ p.x += dx; p.y += dy; }
      } else if(selected.type === 'shape'){
        selected.x1 += dx; selected.y1 += dy; selected.x2 += dx; selected.y2 += dy;
        if(selected.shape === 'circle') selected.r = Math.hypot(selected.x2-selected.x1, selected.y2-selected.y1);
      } else if(selected.type === 'text'){
        selected.x += dx; selected.y += dy;
      }
      selected._dragOffset = {x: pos.x, y: pos.y};
      renderAll();
    }
    return;
  }

  if(currentTool === 'eraser'){
    eraseAt(pos.x,pos.y);
    current = { type: 'eraserCursor', x: pos.x, y: pos.y, size: currentSize };
    renderAll();
    return;
  }

  if(!current) return;
  if(current.type === 'path'){
    current.points.push({x: pos.x, y: pos.y});
  } else if(current.type === 'shape'){
    current.x2 = pos.x; current.y2 = pos.y;
    if(current.shape === 'circle') current.r = Math.hypot(current.x2 - current.x1, current.y2 - current.y1);
  }
  renderAll();
});

canvas.addEventListener('pointerup', (e)=>{
  const pos = getPointerPos(e);
  isPointerDown = false;

  if(currentTool === 'pointer'){
    // finish selecting
    renderAll(); pushHistory(); return;
  }
  if(currentTool === 'eraser'){
    current = null; renderAll(); pushHistory(); return;
  }

  if(!current) return;
  if(current.type === 'path' && current.points.length > 0){ objects.push(current); }
  else if(current.type === 'shape'){ objects.push(current); }
  else if(current.type === 'text'){
    // text input should have been used; if there is text stored, push
    if(current.text && current.text.trim().length){ objects.push(current); }
  }
  current = null; renderAll(); pushHistory();
});

// click outside to deselect
canvas.addEventListener('click', (e)=>{
  if(currentTool === 'pointer' && !isPointerDown){
    const pos = getPointerPos(e);
    let hit = false; for(let i=objects.length-1;i>=0;i--){ if(hitTest(objects[i], pos.x, pos.y)){ hit=true; break;} }
    if(!hit){ selected=null; renderAll(); }
  }
});

// ====== Eraser logic (object-level eraser: removes whole objects touched) ======
function eraseAt(x,y){
  let removed = false;
  for(let i = objects.length - 1; i >= 0; i--){
    if(hitTest(objects[i], x, y)){
      objects.splice(i,1); removed = true;
    }
  }
  if(removed){ renderAll(); }
}

// ====== Text input handling ======
textInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    if(textInput.value.trim().length){
      const rect = canvas.getBoundingClientRect();
      const x = parseFloat(textInput.style.left) - rect.left;
      const y = parseFloat(textInput.style.top) - rect.top;
      const obj = { id: uid('t'), type: 'text', x, y, text: textInput.value, color: currentColor, size: Math.max(12, parseInt(sizePicker.value) * 4) };
      objects.push(obj);
      textInput.value = ''; textInput.style.display = 'none'; pushHistory(); renderAll();
    } else {
      textInput.style.display = 'none';
    }
  }
});

// ====== Toolbar plumbing ======
function setActiveTool(toolId){
  currentTool = toolId;
  document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
  const btn = document.getElementById('tool-' + toolId);
  if(btn) btn.classList.add('active');
}

['pointer','pen','highlighter','eraser','line','rect','circle','text'].forEach(t=>{
  const el = document.getElementById('tool-' + t);
  if(el) el.addEventListener('click', ()=> setActiveTool(t));
});

// color & size
colorPicker.addEventListener('input', ()=> currentColor = colorPicker.value);
sizePicker.addEventListener('input', ()=> currentSize = parseInt(sizePicker.value,10));

// undo/redo/clear
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);
document.getElementById('clearBtn').addEventListener('click', ()=>{ objects = []; backgroundImageDataUrl = null; pushHistory(); renderAll(); });

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'z'){ e.preventDefault(); undo(); }
  if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))){ e.preventDefault(); redo(); }
  if(e.key === 'Delete' && selected){ // delete current selection
    const idx = objects.indexOf(selected); if(idx !== -1) { objects.splice(idx,1); selected = null; pushHistory(); renderAll(); }
  }
});

// ====== PDF import (renders first page as background image) ======
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
const pdfUpload = document.getElementById('pdf-upload');
pdfUpload.addEventListener('change', async (ev)=>{
  const file = ev.target.files[0]; if(!file) return;
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument(new Uint8Array(arrayBuffer)).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({scale: 1.5});
  // render to temporary canvas
  const temp = document.createElement('canvas'); temp.width = viewport.width; temp.height = viewport.height; const tctx = temp.getContext('2d');
  await page.render({canvasContext: tctx, viewport}).promise;
  backgroundImageDataUrl = temp.toDataURL('image/png');
  // resize canvas to fit pdf aspect ratio (fit inside view)
  const ratio = viewport.width / viewport.height;
  const maxW = container.clientWidth - 40; const maxH = container.clientHeight - 40;
  let newW = maxW, newH = Math.round(newW / ratio);
  if(newH > maxH){ newH = maxH; newW = Math.round(newH * ratio); }
  // update viewW/viewH and canvas size
  viewW = newW; viewH = newH;
  canvas.style.width = viewW + 'px'; canvas.style.height = viewH + 'px';
  canvas.width = Math.round(viewW * dpr); canvas.height = Math.round(viewH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  pushHistory(); renderAll();
});

// ====== Export PNG/PDF ======
document.getElementById('export-png').addEventListener('click', ()=>{
  const tmp = document.createElement('canvas'); tmp.width = Math.round(viewW * dpr); tmp.height = Math.round(viewH * dpr); const tctx = tmp.getContext('2d'); tctx.setTransform(dpr,0,0,dpr,0,0);
  // white background
  tctx.fillStyle = '#fff'; tctx.fillRect(0,0,viewW,viewH);
  if(backgroundImageDataUrl){ const img=new Image(); img.onload=()=>{ tctx.drawImage(img,0,0,viewW,viewH); drawAllToCtx(tctx); const link=document.createElement('a'); link.href = tmp.toDataURL('image/png'); link.download = 'whiteboard.png'; link.click(); }; img.src = backgroundImageDataUrl; } else { drawAllToCtx(tctx); const link=document.createElement('a'); link.href = tmp.toDataURL('image/png'); link.download = 'whiteboard.png'; link.click(); }
});

document.getElementById('export-pdf').addEventListener('click', async ()=>{
  const { jsPDF } = window.jspdf;
  // draw everything to a temp canvas first
  const tmp = document.createElement('canvas'); tmp.width = Math.round(viewW * dpr); tmp.height = Math.round(viewH * dpr); const tctx = tmp.getContext('2d'); tctx.setTransform(dpr,0,0,dpr,0,0);
  tctx.fillStyle = '#fff'; tctx.fillRect(0,0,viewW,viewH);
  if(backgroundImageDataUrl){ const img = new Image(); img.onload = ()=>{ tctx.drawImage(img,0,0,viewW,viewH); drawAllToCtx(tctx); const pdf = new jsPDF('l', 'px', [viewW, viewH]); pdf.addImage(tmp.toDataURL('image/png'), 'PNG', 0, 0, viewW, viewH); pdf.save('whiteboard.pdf'); }; img.src = backgroundImageDataUrl; } else { drawAllToCtx(tctx); const pdf = new jsPDF('l','px',[viewW,viewH]); pdf.addImage(tmp.toDataURL('image/png'),'PNG',0,0,viewW,viewH); pdf.save('whiteboard.pdf'); }
});

function drawAllToCtx(tctx){
  // tctx expects same transform in CSS pixels
  for(let obj of objects) {
    if(obj.type === 'path'){
      tctx.save(); tctx.lineCap='round'; tctx.lineJoin='round'; tctx.lineWidth=obj.size; tctx.strokeStyle=obj.color; tctx.globalAlpha = obj.tool === 'highlighter' ? 0.3 : 1; tctx.beginPath(); const pts = obj.points; if(pts.length){ tctx.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++) tctx.lineTo(pts[i].x,pts[i].y); tctx.stroke(); } tctx.restore();
    } else if(obj.type === 'shape'){
      tctx.save(); tctx.lineWidth = obj.size; tctx.strokeStyle = obj.color; if(obj.shape==='line'){ tctx.beginPath(); tctx.moveTo(obj.x1,obj.y1); tctx.lineTo(obj.x2,obj.y2); tctx.stroke(); } if(obj.shape==='rect'){ tctx.strokeRect(Math.min(obj.x1,obj.x2),Math.min(obj.y1,obj.y2),Math.abs(obj.x2-obj.x1),Math.abs(obj.y2-obj.y1)); } if(obj.shape==='circle'){ tctx.beginPath(); const r = obj.r || Math.hypot(obj.x2-obj.x1,obj.y2-obj.y1); tctx.arc(obj.x1,obj.y1,r,0,Math.PI*2); tctx.stroke(); } tctx.restore();
    } else if(obj.type === 'text'){
      tctx.save(); tctx.fillStyle = obj.color; tctx.font = `${obj.size}px sans-serif`; tctx.textBaseline='top'; tctx.fillText(obj.text, obj.x, obj.y); tctx.restore();
    }
  }
}

// ====== Ruler & Protractor draggable ======
function makeDraggable(el){
  let isDown=false, startX=0, startY=0, origLeft=0, origTop=0;
  el.addEventListener('pointerdown', (e)=>{ isDown=true; startX = e.clientX; startY = e.clientY; origLeft = el.offsetLeft; origTop = el.offsetTop; el.setPointerCapture && el.setPointerCapture(e.pointerId); });
  window.addEventListener('pointerup', ()=>{ isDown=false; });
  window.addEventListener('pointermove', (e)=>{ if(!isDown) return; const dx = e.clientX - startX; const dy = e.clientY - startY; el.style.left = (origLeft + dx) + 'px'; el.style.top = (origTop + dy) + 'px'; });
}
makeDraggable(document.getElementById('ruler'));
makeDraggable(document.getElementById('protractor'));

document.getElementById('toggle-ruler').addEventListener('click', ()=>{
  const r = document.getElementById('ruler'); r.style.display = r.style.display === 'block' ? 'none' : 'block';
});

document.getElementById('toggle-protractor').addEventListener('click', ()=>{
  const p = document.getElementById('protractor'); p.style.display = p.style.display === 'block' ? 'none' : 'block';
});

// initialize history
pushHistory();
renderAll();
</script>
</body>
</html>
